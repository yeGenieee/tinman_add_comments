
class ProceduralPublicKey(object):
    """
    A procedural public key to be generated by get_dev_key
    """

    def __init__(self, name):
        self.name = name
        return

class ProceduralPrivateKey(object):
    """
    A procedural private key to be generated by get_dev_key
    """

    def __init__(self, name):
        self.name = name
        return

class ProceduralKeyDatabase(object):
    """
    Every synthetic testnet key is generated by concatenating the name, secret and role.
    This class is the central place these are issued, and keeps track of all of them.
    이름, 비밀값, 역할을 붙여 만든 테스트넷 키
    """
    def __init__(self):
        self.seed2pair = {} # seed2pair 딕셔너리 하나 만듦
        return

    def get(self, name, role="active"):
        seed = role+"-"+name # seed 값은 role(active)과 name을 이어붙인 값
        pair = self.seed2pair.get(seed) # seed값을 키로 가지는 value가 있는지 확인 (처음엔 당연히 없음)
        # print("@@pair "+str(pair))
        if pair is None:
            # print("@@ ProcedualPubkey "+str(ProceduralPublicKey(seed)))
            pair = [ProceduralPublicKey(seed), ProceduralPrivateKey(seed)] # value를 공개키와 개인키의 쌍으로 리스트 만듦
            self.seed2pair[seed] = pair # dict에 저장
            # print("@@@ pair  "+ type(pair))
        return pair

    def get_pubkey(self, name, role="active"):
        return self.get(name, role)[0] # pair에서 PubKey만 가져와

    def get_privkey(self, name, role="active"):
        return self.get(name, role)[1] # pair에서 privkey만 가져와

    # 가중치, 계정, 키 등 권한 가져옴
    def get_authority(self, name, role="active"):
        return {
         "weight_threshold":1,
         "account_auths":[],
         "key_auths":[[self.get_pubkey(name, role),1]],
        }


# 각 공개키나 개인키에 esc 추가
class PubkeySerializer(object):
    """
    We want to defer substitution of public keys to a later
    date.  I.e. we generate an object of a format roughly
    like this:

    {"tx" : {"operations" : [["account_create",{
      "creator" : "alice",
      "new_account_name" : "bob",
      "memo_key" : "bob-memo", ...}]]},
     "signers" : ["alice-active"],
     "pubkeysubs" : ["bob-memo"]
    }

    Then the submitter is responsible for generating the procedural
    keys alice-active and bob-memo, and substituting them in the
    appropriate places.  The challenging problem is that because
    these transactions can contain arbitrary user data, how to ensure
    they are inserted in *only* the appropriate places.

    Some form of escaping is necessary here, but the API provided by
    Python JSON parsing makes it difficult to either extend the JSON
    format to create an entirely new token type, or process all strings
    (allowing for example `{`, `}` to be escaped to `{{`, `}}` and then
    using `str.format()` compatible replacement).

    What we do instead is a two-pass approach:  Serialize as JSON, then
    construct some alphabetical string that does not occur in the
    serialized JSON, and use that as the escape.

    For the first pass, we have no prefix.
    """

    def __init__(self,
        esc="",
        ):
        self.esc = esc
        return

    def __call__(self, obj):
        if isinstance(obj, ProceduralPublicKey):
            return self.esc + "publickey:" + obj.name + self.esc
        if isinstance(obj, ProceduralPrivateKey):
            return self.esc + "privatekey:" + obj.name + self.esc
        return obj
